# üß± General Site Context

## ‚ÑπÔ∏è Context

You are an experienced frontend developer,
mobile developer (mainly iOS and hybrid, but also
android), it architect working at ibm; you are
passionate about coding, and another topic you
really like and doing some experimental projects is
computer vision, extended reality and augmented
reality; you are also experimenting and studying
machine learning, data warehouse, generative ai
(with ai workflows and agents/agentic ai), using
Snowflake (and you will do some demo projects with
it), and AWS (where you got two certifications,
the Solution Architect Associate and the AI
Certified Practitioner). You want to create now
your personal website; you already have a domain
(https://lightstimulus.dev) but with dummy content
for now; you want to develop the whole site.

## üß≠ Purpose

The site should be a personal portfolio site.
It should include a home page, personal projects,
a blog and a contact page. The goal of the site is
the classic one of a developer's personal site, to
promote the image, provide a contact point and show
the projects the developer worked and is currently
working on.
Development priorities: maintainable and extensible architecture (‚âà70%)
combined with expressive visual and animation elements (‚âà30%)
to reflect technical depth and creative experimentation.

## üéØ Target Audience

The target audience can be the most wide possible.
They can be recruiters, collaborators, potential client,
potential employers.

## ‚ú® Tone & Personality

Some adjectives that I expect can describe the site
would be: minimal, techy, futuristic but also experimental

## üì£ Key Messages or Tagline

For the hero section, consider that the domain for the
site is lightstimulus.dev. If you combine the first
two letters of light and the last 5 letters of stimulus,
you get "limulus". The limulus (or to be precise a
combination of the limulus and the concept of light) are
the logo of the site. As many (hopefully the majority)
of the personal projects displayed will be about a
topic very interesting to me (augmented/mixed/extended
reality), the light is connected to this topic. The
hero should contain an animation of the text "Light stimulus",
the animated logo of the site, and maybe some taglines.
Initially I will provide an initial version of the logo that you will
use for an initial animation, just to see the effect on the page,
then we will move to the definitive svg and apply the
definitive animation on that one.
In the hero section:

- The hero should be compact like like mxb.dev
- Tagline animation should be typewriter
- Subtle floating/parallax effect for depth (Think: calm, elegant, ‚ÄúApple keynote‚Äù feel.)
- Logo reveal follows a ‚Äúlight passes through‚Äù or ‚Äúillumination sweep‚Äù concept.
  the light sweep effect should be a glow beam.

Here are some analogies between limulus and light I like (in
italian), so that you can get an inspiration for
a tagline from them:

- Vista a pi√π
  piani ‚Äì I suoi dieci occhi percepiscono la luce
  in modi diversi, simile a come AR/MR combina
  prospettive multiple per un‚Äôesperienza completa.
- Adattamento alla luce ‚Äì Gli occhi del limulo si
  adattano a diverse condizioni luminose, proprio
  come AR/MR deve adattarsi a ambienti reali variabili.
- Antico e futuristico ‚Äì Il limulo √® un fossile
  vivente; la luce rappresenta innovazione: insieme
  evocano continuit√† tra passato e futuro.

Also consider these information on the vision of
limulus, both in italian and English, from the
wikipedia page: Vision Limulus has been extensively
used in research into the physiology of vision.
The Nobel Prize in Medicine was awarded in 1967
in part for research performed on the horseshoe
crab eye. A large compound eye with monochromatic
vision is found on each side of the prosoma;
it has five simple eyes on the carapace, and
two simple eyes on the underside, just in front
of the mouth, making a total of nine eyes.
The simple eyes are probably important during
the embryonic or larval stages of the organism,
and even unhatched embryos seem to be able to
sense light levels from within their buried eggs.
The less sensitive compound eyes, and the median
ocelli, become the dominant sight organs during
adulthood. In addition, the tail bears a series
of light-sensing organs along its length. Each
compound eye is composed of about 1000 receptors
called ommatidia, complex structures consisting of
upwards of 300 cells. The ommatidia are somewhat
messily arranged, not falling into the ordered
hexagonal pattern seen in more derived arthropods.
Each ommatidium feeds into a single nerve fiber.
Furthermore, the nerves are large and relatively
accessible. This made it possible for electrophysiologists
to record the nervous response to light stimulation
easily, and to observe visual phenomena such as
lateral inhibition working at the cellular level.
More recently, behavioral experiments have
investigated the functions of visual perception in
Limulus. Habituation and classical conditioning to
light stimuli have been demonstrated, as has the use
of brightness and shape information by males when
recognizing potential mates. The retinula
(literally, "small retina") cells of the ommatidium
of the compound eye contain areas from which
membranous organelles of conceivable size
(rhabdomeres) extend. Rhabdomeres have tiny
microvilli (tiny tubes extending out of the retinula)
that interlock with neighboring retinular cells.
This forms the rhabdom, which contains the dendrite
of the eccentric cell, and may also contribute some
microvilli. The only other species with an eccentric
cell is the silkworm moth. Microvilli are composed of
a double layer, 7 nm each and with 3.5 nm space of
two electron-deficient boundaries in between. Where
the microvilli meet, these outer borders fuse and
yield five membranes about 15 nm thick. In all
arthropods, there is always a rhabdom below a
crystalline cone, on or near the center of the
ommatidium, and always aligned with the path of
light. At right angles to the length of the
rhabdome are the length of the microvilli, which
are in line with each other. The microvilli are
about 40‚Äì150 nm in diameter.
Visione Il limulo rappresenta un organismo modello
per quanto riguarda gli studi sulla fisiologia
della visione. Il suo apparato visivo √® costituito
da due occhi laterali composti situati in cima al
carapace e 5 occhi semplici sensibili alla luce di
cui due mediani, uno endoparietale e due laterali
rudimentali. Gli occhi composti rappresentano
un'eccezione fra i chelicerati, poich√© nessun'altra
specie appartenente allo stesso subphylum ne
possiede, e vengono utilizzati principalmente per
la localizzazione del partner. Gli occhi mediani
sono sensibili alla luce ultravioletta, oltre a
quella visibile, e insieme agli occhi laterali
rudimentali variano la propria sensibilit√† in base
a segnali inviati dal cervello in relazione a un
orologio interno. Di notte la capacit√† visiva del
limulo arriva ad amplificarsi di un milione di
volte. Una serie di fotorecettori presenti sulla
parte superiore e sui lati del telson inviano
segnali di sincronizzazione al cervello con i cicli
di luce e buio, rafforzati da segnali addizionali
provenienti dai piccoli occhi mediani che aumentano
il grado di adattamento all'oscurit√† in relazione
all'intensit√† di luce ultravioletta. Sul ventre
del limulo, inoltre, sono presenti due occhi,
localizzati vicino alla bocca, che favoriscono
l'orientamento durante il nuoto. Nei due occhi
composti, ciascun ommatidio √® collegato ad una
singola fibra nervosa, molto grande, e ci√≤ ha
consentito lo studio a livello cellulare della
risposta nervosa alla stimolazione. Questi studi,
condotti sui limuli sin dagli anni venti del
ventesimo secolo, hanno permesso l'individuazione
dei meccanismi di funzionamento di fenomeni visivi
come l'inibizione laterale, ovvero la capacit√† di
distinguere linee, forme e contorni degli oggetti.

The animated logo and ‚ÄúLight Stimulus‚Äù text should be SVG-based
Framer Motion animation; the logo and the ‚ÄúLight Stimulus‚Äù text
should be animated as separate reveal for the logo first, then the text.
Propose a few taglines in English and translated into Italian
based on my limulus-light analogies; taglines should cycle automatically
(like a typing effect / fade between phrases). I already have
a SVG file I will provide you later when creating the page.

# üß∞ Tech Stack & Architecture

## ‚öôÔ∏è Framework & Language

The site is made with Next.js 15 and Tailwind

## üé® Styling System

The styling system is TailwindCSS + custom theme file
Theme structure: define design tokens in two layers ‚Äî visual variables (blur, opacity, glass colors) as CSS variables in `theme.css`,
and functional tokens (colors, font sizes, spacing) in `tailwind.config.js`.
Tailwind utilities reference these CSS variables where appropriate, ensuring both runtime flexibility and design consistency.

## üî° Fonts & Icons

- Color palette:
  - Light Theme
    - Background: #F8F9FB ‚Üí very soft,
      bluish off-white
    - Text: #1C1C1E ‚Üí deep neutral for good
      readability
    - Secondary text: #5C5C66 (muted gray-blue for
      metadata, subtitles)
  - Dark Theme (bluer spectrum)
    - Background: #0D1B2A ‚Üí rich deep navy, avoids
      harsh black
    - Text: #E6EDF3 ‚Üí light bluish-white, softer
      than #FFF, matches background‚Äôs hue
    - Secondary text: #9FBACD ‚Üí desaturated light
      blue for metadata/subtitles
  - Accent Colors
    - Primary Accent: #4FD1C5 (teal / cyan) ‚Üí works
      well on both light & dark, futuristic/tech feel
    - Secondary Accent: #FFB347 (warm amber/orange) ‚Üí
      contrast color, good for highlights or call-to-actions
    - Optional Tertiary: #7C3AED (electric violet) ‚Üí
      sparingly, for hover states or special emphasis
    - Usage:
      - Teal = links, key highlights
      - Amber = buttons, hover accents
      - Violet = occasional decorative elements (tags, code highlight keywords, etc.)
  - I will centralize the palette in Tailwind‚Äôs theme extension (tailwind.config.js).
    This allows to
    - Keeps design consistent across components and future refactors.
    - Use semantic tokens like text-primary, bg-accent, etc. instead of raw hex values.
    - Makes theme toggling (light/dark) seamless using Tailwind‚Äôs theme.extend.colors and data-theme or class-based toggles.
    - Simplifies future adjustments (if you tweak teal or background shades).
  - To use utility classes like text-accent-primary instead of hex codes everywhere,
    I will define small ‚Äúsemantic‚Äù groupings, e.g.:
    ```
      extend: {
         colors: {
            background: { light: '#F8F9FB', dark: '#0D1B2A' },
            text: { light: '#1C1C1E', dark: '#E6EDF3' },
            accent: {
               primary: '#4FD1C5',
               secondary: '#FFB347',
               tertiary: '#7C3AED',
            },
         },
      }
    ```
- Fonts:
  - IBM Plex Sans ‚Üí clean, slightly more ‚Äútechy‚Äù,
    subtle personality. A good nod to your IBM role
    without being branded
  - paired with IBM Plex Mono for code snippets in
    the blog
  - Host the fonts locally (import via @next/font/local)
- Icons: Heroicons and Lucide

## üì¶ Additional Libraries / Tools

- ContentLayer: already installed
- MDX + Generative AI Workflows for content:
  Content Source: both blog posts and projects live as
  .mdx files in your repo, so that no CMS is used.
  For now, I will manually generate the mdx files.
  In the future, I would like
  to integrate an AI Generation Workflow: You (or an
  AI workflow/agent) generate Markdown/MDX files
  automatically. The workflow can include metadata
  (title, slug, date, tags, summary) in frontmatter.
  Publishing: Commit the new .mdx file to your
  GitHub repo (via API or GitHub Actions).
  Netlify automatically rebuilds and deploys your
  site with the new content.
- Framer Motion: not installed yet, but this package
  (or another package suggested) should be included to
  manage the animations

## ‚òÅÔ∏è Hosting & Deployment

The site is hosted on Netlify with rebuild and deploys
that starts at every merge on main branch

## üéÅ Package.json file

Here is the package.json file to check if everything
stated before is correct or not; please provide any other
useful package you would install:

```
{
"name": "tailwind-nextjs-starter-blog",
"version": "2.4.0",
"private": true,
"dependencies": {
"@headlessui/react": "2.2.0",
"@heroicons/react": "^2.2.0",
"@next/bundle-analyzer": "15.2.4",
"@tailwindcss/forms": "^0.5.9",
"@tailwindcss/postcss": "^4.0.5",
"@tailwindcss/typography": "^0.5.15",
"body-scroll-lock": "^4.0.0-beta.0",
"clsx": "^2.1.1",
"contentlayer2": "0.5.5",
"cross-env": "^7.0.3",
"esbuild": "0.25.2",
"github-slugger": "^2.0.0",
"gray-matter": "^4.0.2",
"hast-util-from-html-isomorphic": "^2.0.0",
"lucide-react": "^0.545.0",
"next": "^15.5.4",
"next-contentlayer2": "0.5.5",
"next-seo": "^6.8.0",
"next-themes": "^0.4.6",
"pliny": "0.4.1",
"postcss": "^8.4.24",
"react": "19.0.0",
"react-dom": "19.0.0",
"reading-time": "1.5.0",
"rehype-autolink-headings": "^7.1.0",
"rehype-citation": "^2.3.0",
"rehype-katex": "^7.0.0",
"rehype-katex-notranslate": "^1.1.4",
"rehype-preset-minify": "7.0.0",
"rehype-prism-plus": "^2.0.0",
"rehype-slug": "^6.0.0",
"remark": "^15.0.0",
"remark-gfm": "^4.0.0",
"remark-github-blockquote-alert": "^1.2.1",
"remark-math": "^6.0.0",
"tailwindcss": "^4.0.5",
"unist-util-visit": "^5.0.0"
},
"devDependencies": {
"@eslint/eslintrc": "^3.2.0",
"@eslint/js": "^9.16.0",
"@svgr/webpack": "^8.0.1",
"@types/mdx": "^2.0.12",
"@types/react": "^19.0.8",
"@typescript-eslint/eslint-plugin": "^8.12.0",
"@typescript-eslint/parser": "^8.12.0",
"eslint": "^9.14.0",
"eslint-config-next": "15.2.4",
"eslint-config-prettier": "^9.1.0",
"eslint-plugin-prettier": "^5.2.0",
"globals": "^15.12.0",
"husky": "^9.0.0",
"image-size": "^2.0.2",
"lint-staged": "^13.0.0",
"prettier": "^3.0.0",
"prettier-plugin-tailwindcss": "^0.6.11",
"typescript": "^5.1.3"
}
```

## üóÇÔ∏è Folder / Project Structure

This is the current project structure, excluded the
generated folders:
.
‚îú‚îÄ‚îÄ LICENSE  
‚îú‚îÄ‚îÄ README.md  
‚îú‚îÄ‚îÄ app  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Main.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ about  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ newsletter  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ route.ts  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ blog  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ [...slug]  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ page  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ [page]  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ layout.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ not-found.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ page.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ projects  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ robots.ts  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ seo.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ sitemap.ts  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ tag-data.json  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ tags  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ [tag]  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ page  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ [page]  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ page.tsx  
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ theme-providers.tsx  
‚îú‚îÄ‚îÄ components  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Card.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Comments.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Footer.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Header.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Image.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ LayoutWrapper.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Link.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ MDXComponents.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ MobileNav.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PageTitle.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ScrollTopAndComment.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SearchButton.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SectionContainer.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ TableWrapper.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Tag.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ThemeSwitch.tsx  
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ social-icons  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ icons.tsx  
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.tsx  
‚îú‚îÄ‚îÄ contentlayer.config.ts  
‚îú‚îÄ‚îÄ css  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ prism.css  
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ tailwind.css  
‚îú‚îÄ‚îÄ data  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ authors  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ default.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ sparrowhawk.mdx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ blog  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ code-sample.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ deriving-ols-estimator.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ github-markdown-guide.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ guide-to-using-images-in-nextjs.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ introducing-tailwind-nextjs-starter-blog.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ my-fancy-title.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ nested-route  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ introducing-multi-part-posts-with-nested-routing.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ new-features-in-v1.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pictures-of-canada.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ release-of-tailwind-nextjs-starter-blog-v2.0.mdx  
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ the-time-machine.mdx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ headerNavLinks.ts  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logo.svg  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ projectsData.ts  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ references-data.bib  
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ siteMetadata.js  
‚îú‚îÄ‚îÄ eslint.config.mjs  
‚îú‚îÄ‚îÄ faq  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ custom-mdx-component.md  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ customize-kbar-search.md  
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ deploy-with-docker.md  
‚îú‚îÄ‚îÄ jsconfig.json  
‚îú‚îÄ‚îÄ layouts  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ AuthorLayout.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ListLayout.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ListLayoutWithTags.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PostBanner.tsx  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PostLayout.tsx  
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ PostSimple.tsxv
‚îú‚îÄ‚îÄ netlify.toml  
‚îú‚îÄ‚îÄ next-env.d.ts  
‚îú‚îÄ‚îÄ next.config.js  
‚îú‚îÄ‚îÄ package-lock.json  
‚îú‚îÄ‚îÄ package.json  
‚îú‚îÄ‚îÄ postcss.config.js  
‚îú‚îÄ‚îÄ prettier.config.js  
‚îú‚îÄ‚îÄ scripts  
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ postbuild.mjs  
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ rss.mjs  
‚îî‚îÄ‚îÄ tsconfig.json

To improve maintainability, create two additional component folders:

- `/components/ui`: contains reusable UI primitives (Button, Toggle, CardBase, etc.)
- `/components/common`: contains higher-level layout components reused across pages (Header, Footer, Layout, SectionWrapper, etc.)
  This structure separates composable UI elements from layout and logic containers.

## üß≠ Version Control & Workflow

For now, commits, pull requests and merges are made manually
As said, if there is some pull request that is merged into main,
Netlify will trigger an automation to rebuild and deploy the site agian
It would be interesting to add other automations (for example
Github action) but for now don't consider them

# üìÅ Pages & Site Structure

## üåê Overview

Here is a list of all the pages I am considering for now.
In the future I will probably add a newsletter / mailing list
later (like a small audience-builder), but for now keep things
simple and do not add this page. For the key content, I will
provide what I think should be included, but feel free to suggest
any improvement and additional content, or to remove or modify
some content I considered if this is not a best practice/useful
in your opinion.
The site should at least have an home page, a project page,
a bio/about page, a blog page and a contact page.

| Page     | Purpose / Key Content                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Home     | Short intro, featured projects, few of the most recent blog articles. After hero, sections should be Featured Projects ‚Üí Latest Blog -> Simplified contact form -> Footer, on this order; for the homepage, use a scroll-to-section behaviour for anchors (e.g. Projects, Blog); featured project should show 3 or 4 project cards with preview animation; latest blog should show the preview of latest 4 blog articles                                                                                                                                                                                                                                                                                                                                                                                                                            |
| About    | Bio, experience, photo is not mandatory; tone of the page should be "colloquial", without direct references to IBM (even if my current job can be cited)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Projects | All portfolio items with filters; Projects page should only showcase personal/experimental projects (computer vision, XR, Snowflake demos, AI workflows, etc.); projects are stored in mdx files, one for each project; the projects home should have a grid of projects with tags/filters (filters be a sidebar on the left on desktop / dropdown on top of the list on mobile), and clicking on a project should redirect the user to the specific project detail page.the project cards in the main home page and project home page should only have an image and a descriptive content; the project detail page will have more info (more images, longer description, GitHub links and live demo only if possible). Project cards should have hover animations (glassmorphism); project cards should open in dedicated route (/projects/[slug]) |
| Blog     | Articles and notes; blog style should be technical deep dives/tutorials (e.g., Gatsby, XR, AI workflows, SwiftUI tips), and short reflections/essays; blog posts are stored in mdx files, one for each post; like in the starting project, the blog homepage should display a a list with tag filters sidebar on the left and blog posts preview on the right; clicking on a post preview redirect the user to the specific blog post page. Blog cards should have hover animations (glassmorphism)                                                                                                                                                                                                                                                                                                                                                 |
| Contact  | just a simple form that actually sends emails via Netlify Forms; form should be simple name/email/message; in the same page, social links. Form submissions will show inline success or error messages directly within the form area. No modal or page redirect is used.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |

## üß© Global Components

The global component reused across pages should be

- header: should contain the logo, navigation bar to move across
  pages, a search button and a toggle for dark and light switch; header is
  hidden/revealed dynamically; it should appear immediately on page load,
  and we want it to hide on scroll down / reveal on scroll up, using
  smooth fade + translate transitions (like Apple-style);
  at the beginning the header should be transparent
  over the hero then solid on scroll
  Header visibility (hide on scroll down / show on scroll up)
  should be managed with IntersectionObserver rather than scroll listeners
  to ensure optimal performance and smoother transitions.
  The header should also contain a language switcher that will be a compact two-state toggle (EN ‚Üî IT) with flag icons and short text labels.
  A dropdown is not used since only two languages are supported.
- search button: Use Pliny Kbar for local search (cmd+k); in the
  initial header version of the starting project, there is already a
  visible search button in the header. For the scroll behavior for Header,
  it should smoothly fade in/out.
- theme toggle is part of the header and must keep the three options system
  (light / dark / system) and save user preference in local storage
- footer: minimal footer with social links icons for email, github, linkedin,
  and the copyright info; in the future maybe i will add an input to
  subscribe to the newsletter
- a layout wrapper already present in the documents
- please suggest any other cross component that could be userful

## üîó Navigation & Routing

Navigation is performed through the menu in the header that exposes
all the available pages, except for the detail page for blog article
and for project details. The header should not be fixed but about
this make your proposal, always thinking in a creative way
The active link in the navbar should be highlighted

# üé® Styling & Design

## üé® Color Palette

Here is the color palette for the site:

- Color palette:
  - Light Theme
    - Background: #F8F9FB ‚Üí very soft,
      bluish off-white
    - Text: #1C1C1E ‚Üí deep neutral for good
      readability
    - Secondary text: #5C5C66 (muted gray-blue for
      metadata, subtitles)
  - Dark Theme (bluer spectrum)
    - Background: #0D1B2A ‚Üí rich deep navy, avoids
      harsh black
    - Text: #E6EDF3 ‚Üí light bluish-white, softer
      than #FFF, matches background‚Äôs hue
    - Secondary text: #9FBACD ‚Üí desaturated light
      blue for metadata/subtitles
  - Accent Colors
    - Primary Accent: #4FD1C5 (teal / cyan) ‚Üí works
      well on both light & dark, futuristic/tech feel
    - Secondary Accent: #FFB347 (warm amber/orange) ‚Üí
      contrast color, good for highlights or call-to-actions
    - Optional Tertiary: #7C3AED (electric violet) ‚Üí
      sparingly, for hover states or special emphasis
    - Usage:
      - Teal = links, key highlights
      - Amber = buttons, hover accents
      - Violet = occasional decorative elements (tags, code highlight keywords, etc.)

## üî° Typography

Here are the fonts to be used

- Fonts:
  - IBM Plex Sans ‚Üí clean, slightly more ‚Äútechy‚Äù,
    subtle personality. A good nod to your IBM role
    without being branded
  - paired with IBM Plex Mono for code snippets in
    the blog

Typography scale: Keep Tailwind defaults but define
a slightly larger rhythm for headings/subtitles.
Extend Tailwind‚Äôs default font size scale by approximately 1.125√ó for headings and subtitles.  
Apply this rhythm globally via `tailwind.config.js` theme extension to maintain consistency.

## üìè Layout & Spacing

I have no particular indication about container width,
breakpoints, vertical rhythm, padding/margins. Just use the
common ones (for example for breakpoints use Bootstrap library
ones) and anything that is already present in Tailwind or
recommended by Tailwind best practices

## üåó Theme & Mode

The site should have light and dark theme, and the color palette
for these themes is specified in the point above.
The starting project from which I started creating the site already
have a theme switch button in the navigation bar, where the
choices are always light, always dark or to follow system settings.
No specific transition is needed for the passage from light to
dark theme.
No specific transition is needed for the passage from light to
dark theme, keep instant toggle.
The contrasts should follow accessibility rules.
Continue using `next-themes` for theme switching and persistence.  
Future customizations (e.g. animated transitions or color scheme expansions)  
can be layered on top of its context rather than replacing it.
User preferences (theme, language, etc.) are stored in localStorage using namespaced keys prefixed with `lightstimulus.`
(e.g. `lightstimulus.theme`, `lightstimulus.lang`) to avoid conflicts and ensure consistency.

## üí´ Visual Style

I would like a good mix of visual flair and flat/clean/minimal
design, not too much of both of them. As an iOS developer, use some
glassmorphism: glassmorphism level should be slightly pronounced
(e.g., translucent header and cards) but not too invasive.
Looking at the list of site provided
in the next point, I would say that the best is to have
a good balance of a minimalist/clean design (like mxb.dev)
and of something more visual/animated (like rammaheshwari.com),
slightly tending more to the minimalist/clean design;
surely I don't want something very elaborate
like https://tamalsen.dev (that I included more as a reference
to content disposition/site structure more than as a reference
for the graphical aspect).
As a (not too much) subtle reference my iOS background, use
glassmorphism for the header and cards, and for the footer
(the footer is not a card, but a simple div with a
transparent background). Glassmorphism should be around
20‚Äì30% blur + 60% opacity for everything (project cards, blog cards, header, footer)
, but I will evaluate possible changes for specific components
based on the specific context and page when developing that page.
For glassmorphism implementation, use backdrop-filter (true blur),
do not use simulated blur layers.
Glassmorphism parameters (blur, opacity, background color) should be defined as CSS variables in the global theme.  
Components should reference these variables through Tailwind utilities or custom classes,  
so global adjustments can be made without editing multiple components.

## üñºÔ∏è Inspiration References

Here is a list of other developers' sites that you can take
as an inspiration for defining a structure of the page/
disposition of the content of each page for my site and also in
some cases (considering the guidelines provided at the previous
point) as a visual style inspiration:

- https://www.rammaheshwari.com
- https://chaseohlson.com
- https://tamalsen.dev
- https://blog.anniebombanie.com
- https://ianlunn.co.uk
- https://benadam.me
- https://sebkay.com
- https://michaelmannucci.com
- https://mxb.dev

# ‚öôÔ∏è Functional & Behavioral Aspects

## üìà SEO & Metadata

I don't have much technical knowledge about SEO and Metadata to provide
indications for this point. All I can say is that for SEO & discoverability,
site should be optimised both for personal branding (so recruiters,
collaborators, etc. find you easily), and for developer community
traffic (technical blog posts being indexed, discoverable on Google).
As you can see from the project current structure, there is already a
seo.tsx file, a sitemap.ts file, a robot.ts file, a siteMetadata.js file,
and in the package.json the "next-seo" package is included.
Keep one global siteMetadata.js with all general info
(title, url, author, social, etc.).
Localized SEO or text portions (like descriptions or hero subtitles)
will come from translation JSONs or MDX frontmatter,
not from separate metadata files.

## ‚ôø Accessibility Goals

Classic accessibility target should be respected, if the actions to be
taken to fulfill accessibility guidelines are not too strict / have a
negative impact on the site structure or content

## ‚ö° Performance Expectations

No particular performance level is expected, but consider all the possible
optimization you can make (for example lazy loading, image optimization, etc).
At the moment the site should use static export, and for this reason the
image optimization needed to be disabled; use a custom `<Image>` component
wrapping `<img>` with native `loading="lazy"`, fade-in animation on
intersection, and optional blur placeholder.
This replaces Next.js image optimization in the static export context.
The custom `<Image>` component will implement a simple fade-in on intersection, without blurhash or LQIP placeholders, to keep performance and bundle size optimal for static export.
Here is the current content of
the next.config.js file:

```
const { withContentlayer } = require('next-contentlayer2')

const withBundleAnalyzer = require('@next/bundle-analyzer')({
enabled: process.env.ANALYZE === 'true',
})

// You might need to insert additional domains in script-src if you are using external services
const ContentSecurityPolicy = `
  default-src 'self';
  script-src 'self' 'unsafe-eval' 'unsafe-inline' giscus.app analytics.umami.is;
  style-src 'self' 'unsafe-inline';
  img-src * blob: data:;
  media-src *.s3.amazonaws.com;
  connect-src *;
  font-src 'self';
  frame-src giscus.app
`

const securityHeaders = [
// https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP
{
key: 'Content-Security-Policy',
value: ContentSecurityPolicy.replace(/\n/g, ''),
},
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy
{
key: 'Referrer-Policy',
value: 'strict-origin-when-cross-origin',
},
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
{
key: 'X-Frame-Options',
value: 'DENY',
},
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
{
key: 'X-Content-Type-Options',
value: 'nosniff',
},
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control
{
key: 'X-DNS-Prefetch-Control',
value: 'on',
},
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
{
key: 'Strict-Transport-Security',
value: 'max-age=31536000; includeSubDomains',
},
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy
{
key: 'Permissions-Policy',
value: 'camera=(), microphone=(), geolocation=()',
},
]

const output = 'export' // always generate static export
const basePath = process.env.BASE_PATH || undefined

/**
* @type {import('next/dist/next-server/server/config').NextConfig}
  **/
  module.exports = () => {
  const plugins = [withContentlayer, withBundleAnalyzer]
  return plugins.reduce((acc, next) => next(acc), {
  output,
  basePath,
  reactStrictMode: true,
  trailingSlash: false,
  pageExtensions: ['ts', 'tsx', 'js', 'jsx', 'md', 'mdx'],
  eslint: {
  dirs: ['app', 'components', 'layouts', 'scripts'],
  },
  images: {
  remotePatterns: [
  {
  protocol: 'https',
  hostname: 'picsum.photos',
  },
  ],
  unoptimized: true,
  },
  async headers() {
  return [
  {
  source: '/(.*)',
  headers: securityHeaders,
  },
  ]
  },
  webpack: (config, options) => {
  config.module.rules.push({
  test: /\.svg$/,
  use: ['@svgr/webpack'],
  })

  return config
  },
  })
  }
```

## üß© Reusability & UI Kit

The components you will generate should be as reusable as possible but
this should not influence other decisions you can take when creating the
site pages (for example, is it ok to create two different project cards,
if this will ever be a component for the site, if one card works better in the
homepage and the other card works better in the projects page)
No particular UI Kit or design token will be used, the styling will be
made with the Tailwind library and Tailwind configurations as said before.
For the component architecture, do not use separate client/server
components strictly per Next.js best practice (e.g. Header = client, Footer/Layout = server),
use a simpler all-client structure for uniform animation/state handling.
All UI components (Header, Footer, Layout, etc.) should remain client components for consistency in state and animation.  
Use server components only for metadata or static SEO injection inside layout files.

## üß† Analytics & Integrations

At the moment no particular analytics service is requested, even if
in the starting project I see that another library from the same author
of the starting project is included in the dependencies ([Pliny](https://github.com/timlrx/pliny)).
I will add other info about this package and its Readme file in the "Optional extras" section
For now, just keep a placeholder for the analytics, don't activate one yet.
The contact form should use Netlify Forms, and the social links
should be added to the footer. The form should submit directly
and show a custom success message if the form is submitted successfully.
In case of error, the validation should be made also on
the client side (basic name/email/message.

## üîí Privacy or Legal

As before, I don't have much knowledge about privacy and legal topics.
Evaluate is something needs to be added to manage cookie banners and
privacy policy. In the starting project, I don't see any cookie banner
or privacy policy section, and for now I don't expect to use cookies or
similar to track user, but add anything needed for any eventual legal
requisite that the site can require.

# üß© Optional Extras

## üéûÔ∏è Animations

I would like a combination of subtle microinteractions and full entrance
animations. Subtle interactions should enhance the user experience
(hover effects, button feedback, scroll-triggered reveals), while
entrance animations should make key sections like the hero, feature
highlights, or calls-to-action more engaging when they appear in
the viewport. The goal is a polished, dynamic feel without
overwhelming the user. Consistent microinteractions (hover, scroll reveal timings)
distinct hero animation (unique logo + text sequence)
Slightly differentiated section reveals
(same motion language, different direction/intensity)
Use Motion.dev (in its latest stable release) as the unified animation
library (for hero + microinteractions), not Framer Motion.
For microinteractions (hover, small fade/scale transitions), use TailwindCSS built-in transition utilities.  
Use Motion.dev exclusively for structured animations (hero reveal, section entrance, scroll-triggered, or complex sequences).  
Do not import Motion for basic hover states.
Use the latest stable version of `@motion.dev/react` (Motion.dev) as the unified animation library for all structured animations (hero reveal, section entrances, scroll-triggered sequences).
Framer Motion will not be used.
Tailwind transitions will continue to handle microinteractions (hover, small opacity/scale effects).
All animation utilities and motion presets will be defined in a dedicated `/lib/motion` folder for reuse.

## üåç Internationalization

The site should support both English and Italian. Detect the
preferred language automatically on first visit
but always display a language toggle in the header as a icon
based toggle with flags and language description short text
(e.g.‚ÄúEN", "IT‚Äù) to change language programmatically.
When switching language, the hero tagline switch language instantly (no animation).
In general, when switching languages, content will switch instantly
without any sort of fade transition or other transition/animation.
Store the user‚Äôs preference in localStorage so it persists.
As default, the site should auto redirect on browser locale
(Italian if locale is Italian, English if locale is English and
as a fallback option for every other locale that is not Italian);
the user can then switch manually and the choice must be saved
in local storage.
The header should also contain a language switcher that will be a compact two-state toggle (EN ‚Üî IT) with flag icons and short text labels.
A dropdown is not used since only two languages are supported.
For translation storage, use JSON files under /locales for UI/static text,
and use MDX frontmatter with localized fields for Page content (MDX posts).
English should be primary language as it is fallback for every
language other than Italian, but probably most of the users will be
Italian so the content must be perfect in Italian too.
You should keep a single route and switch language internally,
so URLs must remain clean (e.g. "/" always, internal language
switch), and not localized paths (e.g. /it/..., /en/...).
Translations must be preloaded for both languages at runtime
(since the site is small and static)
I will use a lightweight custom JSON + React context hook system,
because in this case a simple internal i18n layer
(like /locales/en.json and /locales/it.json)
with a LanguageProvider context is more reliable, transparent,
and easier to extend. I will preload both languages on app init
and cache the selection in localStorage.
Keep /locales/en.json and /locales/it.json only for UI/static strings
(menu, buttons, taglines).
Keep SEO, meta descriptions, and long text inside:

- siteMetadata.js (shared global metadata)
- MDX frontmatter (per-page localized fields)

The LanguageProvider should be initialized in `app/layout.tsx` at the root level
to ensure consistent language context across the entire app (including metadata, menus, and animations).

## üìù Blog or CMS Setup

For the blog articles and projects content, I will use Markdown/MDX (no CMS).
We will design the MDX frontmatter structure together
(fields like title, tags, summary, slug, coverImage, date, lang, etc.)
before implementing list layouts.
In the process, I will store blog posts and projects as .mdx in the repo
for lowest complexity and highest control. In the future, the idea is to
automate some content generation with AI:

- Content Source: blog posts and projects live as .mdx files in your repo.
  AI Generation:
- You (or an AI workflow/agent) generate Markdown/MDX files automatically.
  The workflow can include metadata (title, slug, date, tags, summary) in frontmatter.
- Publishing:
  Commit the new .mdx file to your GitHub repo (via API or GitHub Actions).
  Netlify automatically rebuilds and deploys your site with the new content.

As said in the previous section, this approach must manage also the
internationalization/the fact that all the articles are present in all
the supported languages. At the beginning, I will provide a double version of
the article (in italian and english), but I will try to automate the generation
of the other languages.
No comments enabled (e.g., via Giscus or Disqus) for now, keep it read-only
for now.
Use a single MDX file per article/project, with dual-language
frontmatter fields, e.g.:

```
title:
en: "Exploring AR Depth APIs"
it: "Esplorando le API di profondit√† AR"
summary:
en: "An overview of how depth sensing enhances AR experiences."
it: "Una panoramica su come la percezione della profondit√† migliora le esperienze AR."
date: "2025-05-20"
tags: ["AR", "computer vision"]
coverImage: "/images/depth-ar.jpg"
```

Define two separate Contentlayer document types: `Blog` and `Project`.  
Each will include dual-language fields (`title`, `summary`, etc.)  
and a shared field set for date, tags, slug, coverImage, and language.  
Keeping them distinct simplifies filtering and routing.

## üß∞ Build / Dev Tools

I will configure (with your support) Husky pre-commit hooks
to run lint + prettier automatically.
No need to add other tools like storybook.

## üöÄ Deployment Workflow

Deployment is made through Netlify where the site is hosted. Each change will
be made on a feature branch and when the feature branch is merged into
main branch, the netlify pipeline will trigger and deploy the new site.
I think netlify can also manage changes previews, but I don't know exactly how
to use it. For now, I check for the site preview through local building and
running. Netlify is already linked to my repo, so it is not necessary to
include initial setup instructions for it in the project plan. For now, I will
not use Netlify build previews during development.

## ‚ÑπÔ∏è Additional info on Pliny library

Here is what the author of the starter project (https://github.com/timlrx/tailwind-nextjs-starter-blog)
wrote in the "Release of Tailwind Nextjs Starter Blog template v2.0" blog article
about the starter project setup and the Pliny library/package:

```
## Introduction

Welcome to the release of Tailwind Nextjs Starter Blog template v2.0. This release is a major refactor of the codebase to support Nextjs App directory and React Server Components. Read on to discover the new features and how to migrate from V1.

<TOCInline toc={props.toc} exclude="Introduction" />

## V1 to V2

![Github Traffic](/static/images/github-traffic.png)

The template was first released in January 2021 and has since been used by thousands of users. It is featured on [Next.js Templates](https://vercel.com/templates/next.js/tailwind-css-starter-blog), [Tailwind Awesome](https://www.tailwindawesome.com/resources/tailwind-nextjs-starter-blog) among other listing sites. It attracts 200+ unique visitors daily notching 1500-2000 page views, with 1.3k forks and many other clones.

Many thanks to the community of users and contributors for making this template a success! I created a small video montage of the blogs (while cleaning up the list in the readme) to showcase the diversity of the blogs created using the template and to celebrate the milestone:

<video controls>
  <source
    src="https://github-production-user-asset-6210df.s3.amazonaws.com/28362229/258559849-2124c81f-b99d-4431-839c-347e01a2616c.webm"
    type="video/webm"
  />
</video>

Version 2 builds on the success of the previous version and introduces many new features and improvements. The codebase has been refactored to support Next.js App directory and React Server Components. Markdown / MDX is now processed using Contentlayer, a type-safe content SDK that validates and transforms your content into type-safe JSON data. It integrates with Pliny, a new library that provides out of the box Next.js components to enhance your static site with analytics, comments and newsletter subscription. A new command palette (‚åò-k) search component is also added to the template.

Let's dive into the new features and improvements in V2.

## Next.js App Directory and React Server Components

Now that [Next.js App router](https://nextjs.org/docs/app) is finally stable and is mostly feature compatible with Page Router, the codebase has been migrated to new setup. This allows for a hybrid rendering approach, with the use of React Server Components generated on the server side for faster page loads and smaller bundle sizes, while retaining the ability to sprinkle in client side React components for interactivity.[^1]

With addition powers comes a [new paradigm](https://nextjs.org/docs/getting-started/react-essentials) to learn. I have migrated the codebase to make use of the new features as much as possible. This includes changes in the folder structure, splitting components into server vs client components, leveraging server side data fetching and using the recommended [Metadata](https://nextjs.org/docs/app/building-your-application/optimizing/metadata) API for SEO discoverability.

While this simplifies the codebase to some extent, it makes migration from the old codebase more difficult. If you are looking to migrate, I recommend starting from a fresh template and copying over your customizations and existing content. See the [migration recommendations](#migration-recommendations) section for more details.

## Typescript First

The codebase has been migrated to Typescript. While the previous version of the template was available in both Javascript and Typescript, I decided to reduce the maintenance burden and focus on Typescript. This also allows for better type checking and code completion in IDEs.

Typescript is also a perfect match with our new type-safe markdown processor - Contentlayer.

## Contentlayer

[Contentlayer](https://www.contentlayer.dev/) is a content SDK that validates and transforms your content into type-safe JSON data that you can easily import into your application. It makes working with local markdown or MDX files a breeze. This replaces `MDX-bundler` and our own markdown processing workflow.

First, a content source is defined, specifying the name of the document type, the source where it is located along with the frontmatter fields and any additional computed fields that should be generated as part of the process.

ts:contentlayer.config.ts
export const Blog = defineDocumentType(() => ({
  name: 'Blog',
  filePathPattern: 'blog/**/*.mdx',
  contentType: 'mdx',
  fields: {
    title: { type: 'string', required: true },
    date: { type: 'date', required: true },
    tags: { type: 'list', of: { type: 'string' }, default: [] },
    ...
  },
  computedFields: {
    readingTime: { type: 'json', resolve: (doc) => readingTime(doc.body.raw) },
    slug: {
      type: 'string',
      resolve: (doc) => doc._raw.flattenedPath.replace(/^.+?(\/)/, ''),
    }
    ...
  },
}))


Contentlayer then processes the MDX files with our desired markdown remark or rehype plugins, validates the schema, generate type definitions and output json files that can be easily imported in our pages. Hot reloading comes out of the box, so edits to the markdown files will be reflected in the browser immediately!

## Pliny

A large reason for the popularity of the template was its customizability and integration with other services from analytics providers to commenting solutions. However, this means that a lot of boilerplate code has to be co-located within the template even if the user does not use the feature. Updates and bug fixes had to be copied manually to the user's codebase.

To solve this, I have abstracted the logic to a separate repository - [Pliny](https://github.com/timlrx/pliny). Pliny provides out of the box Next.js components to enhance static sites:

- Analytics
    - Google Analytics
    - Plausible Analytics
    - Simple Analytics
    - Umami Analytics
    - Posthog
- Comments
    - Disqus
    - Giscus
    - Utterances
- Newsletter (uses Next 13 API Routes)
    - Buttondown
    - Convertkit
    - Email Octopus
    - Klaviyo
    - Mailchimp
    - Revue
- Command palette search with tailwind style sheet
    - Algolia
    - Kbar (local search)
- UI utility components
    - Bleed
    - Newsletter / Blog Newsletter
    - Pre / Code block
    - Table of Contents

Choose your preferred service by modifying `siteMetadata.js` and changing the appropriate fields. For example to change from Umami Analytics to Plausible, we can change the following fields:

diff-js:siteMetadata.js
analytics: {
-   umamiAnalytics: {
-     // We use an env variable for this site to avoid other users cloning our analytics ID
-     umamiWebsiteId: process.env.NEXT_UMAMI_ID, // e.g. 123e4567-e89b-12d3-a456-426614174000
-   },
+    plausibleAnalytics: {
+      plausibleDataDomain: '', // e.g. tailwind-nextjs-starter-blog.vercel.app
+    },
},


Changes in the configuration file gets propagated to the components automatically. No modification to the template is required.

Under the hood, Pliny exports high level components such as `<Analytics analyticsConfig={analyticsConfig}/>` and `<Comments commentsConfig={commentsConfig}/>` which takes in a configuration object and renders the appropriate component. Since the layouts are defined on the server side, Next.js is able to use the configuration object to determine which component to render and send only the required component bundle to the client.

## New Search Component

What's a blog in 2023 without a command palette search bar?

One of the most highly requested features have been added üéâ! The search component supports 2 search providers - Algolia and Kbar local search.

### Algolia

[Algolia Docsearch](https://docsearch.algolia.com/) is popular free service used across many documentation websites. It automatically scrapes the website that has is submitted for indexing and makes the search result available via a beautiful dialog modal. The pliny component is greatly inspired by the Docusaurus implementation and comes with a stylesheet that is compatible with the Tailwind CSS theme.

### Kbar

[Kbar](https://github.com/timc1/kbar) is a fast, portable, and extensible cmd+k interface. The pliny implementation uses kbar to create a local search dialog box. The component loads a JSON file, default `search.json`, that was created in the contentlayer build process. Try pressing ‚åò-k or ctrl-k to see the search bar in action!

## Styling and Layout Updates

### Theming

`tailwind.config.js` has been updated to use tailwind typography defaults where possible and to use the built-in support for dark mode via the `prose-invert` class. This replaces the previous `prose-dark` class and configuration.

The primary theme color is updated from `teal` to `pink` and the primary gray theme from `neutral` to `gray`.

Inter is now replaced with Space Grotesk as the default font.

### New Layouts

Layout components available in the `layouts` directory, provide a simple way to customize the look and feel of the blog.[^2]

The downside of building a popular template is that you start seeing multiple similar sites everywhere üòÜ. While users are encouraged to customized the layouts to their liking, having more layout options that are easily switchable promotes diversity and perhaps can be a good starting point for further customizations.

In v2, I added a new post layout - `PostBanner`. It features a large banner image and a centered content container. Check out "[Pictures of Canada](/blog/pictures-of-canada)" blog post which has been updated to use the new layout.

The default blog listing layout has also been updated to include a side bar with blog tags. The search bar in the previous layout has been replace with the new command palette search. To switch back to the old layout, simply change the pages that use the `ListLayoutWithTags` component back to the original `ListLayout`.

## Migration Recommendations

Due to the large changes in directory structure, setup and tooling, I recommend starting from a fresh template and copying existing content, followed by incrementally migrating changes over to the new template.

Styling changes should be relatively minor and can be copied over from the old `tailwind.config.js` to the new one. If copying over, you might need to add back the `prose-dark` class to components that opt into tailwind typography styling. Do modify the font import in the root layout component to use the desired font of choice.

Changes to the MDX processing pipeline and schema can be easily ported to the new Contentlayer setup. If there are changes to the frontmatter fields, you can modify the document type in `contentlayer.config.ts` to include the new fields. Custom plugins can be added to the `remarkPlugins` and `rehypePlugins` properties in the `makeSource` export of `contentlayer.config.ts`.

Markdown layouts are no longer sourced automatically from the `layouts` directory. Instead, they have to be specified in the `layouts` object defined in `blog/[...slug]/page.tsx`.[^3]

To port over larger components or pages, I recommend first specificing it as a client component by using the `"use client"` directive. Once it renders correctly, you can split the interactive components (parts that rely on `use` hooks) as a client component and keep the remaining code as a server component. Consult the comprehensive Next.js [migration guide](https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration#migrating-from-pages-to-app) for more details.
```

and here is the Pliny library readme file:

```
Pliny

Pliny provides out of the box components to enhance your static site:

Analytics
Google Analytics
Plausible Analytics
Simple Analytics
Umami Analytics
Posthog
Microsoft Clarity
Comments
Disqus
Giscus
Utterances
Newsletter (uses Next 13 API Routes)
Buttondown
Convertkit
Email Octopus
Klaviyo
Mailchimp
Beehiiv
Command palette search with tailwind style sheet
Algolia
Kbar (local search)
UI utility components
Bleed
Newsletter / Blog Newsletter
Pre / Code block
Table of Contents
as well as a bunch of MDX and contentlayer utility functions which I use to build Tailwind Nextjs Starter Blog and my own sites.

It is based on Next.js, Tailwind CSS and Contentlayer. For an example of how all the components can be used together, check out the Tailwind Nextjs Starter Blog.

Note: The previous cli and starter template have been deprecated. Please use the new components directly in your favourite Next 13 websites.

Note 2: The components are intended to be use within Next 13 app directory setup with Contentlayer. You might still be able to use the components in older websites but there's no official support for it, especially since many components are now using next/navigation instead of next/router.

This project is still in beta. Please report any issues or feedbacks.

Installation

npm i pliny
As many of the components are styled with tailwindcss, you will need to include the path to the library within the content section of your tailwind config file:

module.exports = {
  content: [
    './node_modules/pliny/**/*.js',
    './pages/**/*.{html,js}',
    './components/**/*.{html,js}',
  ],
  // ...
}
Components

Analytics

The Analytics component provides an easy interface to switch between different analytics providers. It might not be as feature rich as the official analytics providers but it should be sufficient for simple use cases.

All components default to the hosted service, but can be configured to use a self-hosted or proxied version of the script by providing the src / apiHost props to the respective analytics component.

Note: As an external script will be loaded, do ensure that script-src in the content security policy of next.config.js has been configured to whitelist the domain.

import { Analytics, AnalyticsConfig } from 'pliny/analytics'

const analytics: AnalyticsConfig = {
    // If you want to use an analytics provider you have to add it to the
    // content security policy in the `next.config.js` file.
    // supports Plausible, Simple Analytics, Umami, Posthog or Google Analytics.
    plausibleAnalytics: {
      plausibleDataDomain: '', // e.g. tailwind-nextjs-starter-blog.vercel.app
    },
    simpleAnalytics: {},
    umamiAnalytics: {
      umamiWebsiteId: '', // e.g. 123e4567-e89b-12d3-a456-426614174000
    },
    posthogAnalytics: {
      posthogProjectApiKey: '', // e.g. 123e4567-e89b-12d3-a456-426614174000
    },
    googleAnalytics: {
      googleAnalyticsId: '', // e.g. G-XXXXXXX
    },
    clarityAnalytics: {
      ClarityWebsiteId: '', // e.g. abcdefjhij
    },
  }

export default function Layout() {
  return (
    ...
    <Analytics analyticsConfig={analyticsConfig} />
  )
}
You can also use the individual analytics components directly.

Google Analytics

import { GA } from 'pliny/analytics/GoogleAnalytics'

const googleAnalyticsId = '' // e.g. UA-000000-2 or G-XXXXXXX

export default function Layout() {
  return (
    ...
    <GA googleAnalyticsId={googleAnalyticsId} />
  )
}
Microsoft Clarity Analytics

import { GA } from 'pliny/analytics/MicrosoftClarity'

const ClarityWebsiteId = '' // e.g. abcdefjhij

export default function Layout() {
  return (
    ...
    <Clarity ClarityWebsiteId={ClarityWebsiteId} />
  )
}
Plausible Analytics

import { Plausible } from 'pliny/analytics/Plausible'

const plausibleDataDomain = '' // e.g. tailwind-nextjs-starter-blog.vercel.app

export default function Layout() {
  return (
    ...
    <Plausible plausibleDataDomain={plausibleDataDomain} />
  )
}
Simple Analytics

import { SimpleAnalytics } from 'pliny/analytics/SimpleAnalytics'

export default function Layout() {
  return (
    ...
    <SimpleAnalytics />
  )
}
Umami Analytics

import { Umami } from 'pliny/analytics/Umami'

const umamiWebsiteId = '' // e.g. 123e4567-e89b-12d3-a456-426614174000

export default function Layout() {
  return (
    ...
    <Umami umamiWebsiteId={umamiWebsiteId} />
  )
}
Posthog

import { Posthog } from 'pliny/analytics/Posthog'

const posthogProjectApiKey: '', // e.g. AhnJK8392ndPOav87as450xd

export default function Layout() {
  return (
    ...
    <Posthog posthogProjectApiKey={posthogProjectApiKey} />
  )
}
Comments

The Comments component provides an easy interface to switch between different comments providers.

import { Comments, CommentsConfig } from 'pliny/comments'
import siteMetadata from '@/data/siteMetadata'

export default function BlogComments({ slug }: { slug: string }) {
  return <Comments commentsConfig={commentsConfig as CommentsConfig} slug={slug} />
}
You can also use the individual comments components directly.

Giscus

import { Giscus, GiscusProps } from 'pliny/comments/Giscus'

export default function BlogComments(props: GiscusProps) {
  return <Giscus {...props} />
}
Disqus

import { Disqus, DisqusProps } from 'pliny/comments/Disqus'

export default function BlogComments(props: DisqusProps) {
  return <Disqus {...props} />
}
Utterances

import { Utterances, UtterancesProps } from 'pliny/comments/Utterances'

export default function BlogComments(props: UtterancesProps) {
  return <Utterances {...props} />
}
Newsletter

The Newsletter component provides a Next 13 API route to integrate a newsletter subscription API with various providers. E.g. in app/api/newsletter/route.ts

import { NewsletterAPI } from 'pliny/newsletter'
import siteMetadata from '@/data/siteMetadata'

const handler = NewsletterAPI({
  provider: '', // Use one of mailchimp, buttondown, convertkit, klaviyo emailOctopus
})

export { handler as GET, handler as POST }
You can then send a POST request to the API route with a body with the email - { email: 'new_email@gmail.com' }. See the NewsletterForm component in pliny/ui/NewsletterForm for an example.

Search

The Search component provides an easy interface to switch between different search providers. If you are using algolia, you will need to import the css file as well - import 'pliny/search/algolia.css'.

import { SearchProvider, SearchConfig } from 'pliny/search'

export default function Layout() {
  return <SearchProvider searchConfig={searchConfig as SearchConfig}>...</SearchProvider>
}
You can also use the individual search components directly.

Kbar

You can pass in an optional defaultActions to kbarConfig to customize the default actions. See Kbar documentation for more details.

import { KBarSearchProvider } from 'pliny/search/KBar'

export default function Layout() {
  return <KBarSearchProvider kbarConfig={{ searchDocumentsPath: 'abc' }}>...</KBarSearchProvider>
}
Use KBarButton to add a button which toggles the command palette on click event.

import { KBarButton } from 'pliny/search/KBarButton'

export default function SearchButton() {
  return (
    <KBarButton aria-label="Search Content">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        strokeWidth={1.5}
        stroke="currentColor"
        className="w-6 h-6"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
        />
      </svg>
    </KBarButton>
  )
}
Algolia

import 'pliny/search/algolia.css'
import { AlgoliaSearchProvider } from 'pliny/search/Algolia'

export default function Layout() {
  return (
    <AlgoliaSearchProvider
      algoliaConfig={{
        appId: 'R2IYF7ETH7',
        apiKey: '599cec31baffa4868cae4e79f180729b',
        indexName: 'docsearch',
      }}
    >
      ...
    </AlgoliaSearchProvider>
  )
}
Use AlgoliaButton to add a button which toggles the command palette on click event.

import { AlgoliaButton } from 'pliny/search/AlgoliaButton'

export default function SearchButton() {
  return (
    <AlgoliaButton aria-label="Search Content">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        strokeWidth={1.5}
        stroke="currentColor"
        className="w-6 h-6"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
        />
      </svg>
    </AlgoliaButton>
  )
}
MDX plugins

Add the plugins to remarkPlugins in contentlayer or other MDX processors.

Remark Extract Frontmatter

Extracts frontmatter from markdown file and adds it to the file's data object. Used to pass frontmatter fields to subsequent remark / rehype plugins.

Remark code title

Parses title from code block and inserts it as a sibling title node.

Remark Img To Jsx

Converts markdown image nodes to next/image jsx.

Remark TOC Headings

Extracts TOC headings from markdown file and adds it to the file's data object. Alternatively, it also exports a extractTocHeadings function which can be used within contentlayer to create a computedField with the TOC headings.

MDX components

While these can be used in any React code, they can also be passed down as MDXComponents and used within MDX files.

Bleed

Useful component to break out of a constrained-width layout and fill the entire width.

Pre / Code block

Simple code block component with copy to clipboard button.

TOCInline

Table of contents component which can be used within a markdown file. asDisclosure will wrap the TOC in a details element with a summary element. collapse will collapse the TOC when AsDisclosure is true. Modify the list style by passing in a ulClassName and liClassName prop. For example, if you are using Tailwind css and want to revert to the default HTML list style set ulClassName="[&_ul]:list-[revert]" and you want to change styles of your list items liClassName="underline decoration-sky-500" .

NewsletterForm / BlogNewsletterForm

Newsletter form component to add a subscriber to your mailing list.
```
